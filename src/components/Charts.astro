---
import type { Listing, MarketModel } from '../utils/analysis';

interface Props {
    listings: Listing[];
    model: MarketModel;
}

const { listings, model } = Astro.props;

// 1. Prepare Market Data
const marketPoints = listings
    .filter(l => l.price > 100000 && l.sqft > 0 && l.year > 0)
    .map(l => ({
        x: l.sqft,
        y: l.price,
        year: l.year,
        address: l.address,
        url: l._sourceUrl
    }));

// 2. Prepare Accuracy Data
const currentYear = new Date().getFullYear();
const accuracyPoints = listings
    .filter(l => l.price > 100000 && l.sqft > 300)
    .map(l => {
        const age = currentYear - l.year;
        const isDouble = l.parkingType === 'garage_double' ? 1 : 0;
        const isTandem = l.parkingType === 'garage_tandem' ? 1 : 0;
        const locationStr = `${l.city} - ${l.subArea || 'Other'}`;
        const locCoef = model.areaCoefficients[locationStr] || 0;
        const isEnd = l.isEndUnit ? 1 : 0;
        const hasAC = l.hasAC ? 1 : 0;
        const baths = l.bathrooms || 1;
        const feePerSqft = l.sqft > 0 ? (l.fee || 0) / l.sqft : 0;
        const condition = l.condition || 3;
        const isRainscreen = l.rainscreen ? 1 : 0;
        const hasTax = (l.propertyTax && l.propertyTax > 0) ? 1 : 0;
        const taxPerSqft = (hasTax && l.sqft > 0) ? l.propertyTax / l.sqft : 0;

        // Log Linear Logic: Sum of coefs
        const predictedLog = model.intercept +
            (l.sqft * model.coefSqft) +
            (age * model.coefAge) +
            (baths * model.coefBath) +
            (feePerSqft * model.coefFee) +
            (condition * model.coefCondition) +
            (isRainscreen * model.coefRainscreen) +
            (hasAC * model.coefAC) +
            (isEnd * model.coefEndUnit) +
            (isDouble * model.coefDoubleGarage) +
            (isTandem * model.coefTandemGarage) +
            locCoef +
            (taxPerSqft * model.coefTax) +
            (hasTax * model.coefHasTax);

        const predicted = Math.exp(predictedLog);

        return {
            actual: l.price,
            predicted: Math.round(predicted),
            address: l.address,
            url: l._sourceUrl,
            diff: Math.abs(l.price - predicted)
        };
    });

// 3. Prepare Feature Impact Data
// For Log-Linear, we show the % impact or Dollar impact on the AVERAGE home price
// This makes the chart readable.
const avgPrice = marketPoints.reduce((sum, p) => sum + p.y, 0) / marketPoints.length || 900000;

const areaPoints = Object.entries(model.areaCoefficients)
    .map(([k, v]) => {
        // Impact = AvgPrice * (e^v - 1)
        const impact = avgPrice * (Math.exp(v) - 1);
        return {
            label: k === model.areaReference ? `${k} (Baseline)` : k,
            value: impact,
            isBaseline: k === model.areaReference,
            tStat: model.tStats.areaCoefficients[k] || 0
        };
    })
    .sort((a, b) => b.value - a.value);

const cities = [...new Set(Object.keys(model.areaCoefficients).map(k => k.split(' - ')[0]))].sort();
const defaultCities = ['Coquitlam', 'Port Coquitlam', 'Port Moody'];

// Helper to calc dollar impact of a dummy variable
const calcImpact = (coef: number) => avgPrice * (Math.exp(coef) - 1);
// For continuous vars (Age, Fee), show impact of "1 Unit" or "Standard Step"
const calcLinearImpact = (coef: number, step: number) => avgPrice * (Math.exp(coef * step) - 1);

// Thresholds for showing features in chart
const VALUE_THRESHOLD = 1000;
const TSTAT_THRESHOLD = 1.0;

const allFeatures = [
    { label: 'Double Garage', value: calcImpact(model.coefDoubleGarage), tStat: model.tStats.coefDoubleGarage },
    { label: 'Tandem Garage', value: calcImpact(model.coefTandemGarage), tStat: model.tStats.coefTandemGarage },
    { label: 'End Unit', value: calcImpact(model.coefEndUnit), tStat: model.tStats.coefEndUnit },
    { label: 'Air Con', value: calcImpact(model.coefAC), tStat: model.tStats.coefAC },
    { label: 'Rainscreen', value: calcImpact(model.coefRainscreen), tStat: model.tStats.coefRainscreen },
    { label: 'Extra Bath', value: calcLinearImpact(model.coefBath, 1), tStat: model.tStats.coefBath },
    { label: 'Extra Bedroom', value: calcLinearImpact(model.coefBedrooms, 1), tStat: model.tStats.coefBedrooms },
    { label: 'Condition (+1)', value: calcLinearImpact(model.coefCondition, 1), tStat: model.tStats.coefCondition },
    { label: 'Newer (10 Yrs)', value: calcLinearImpact(model.coefAge, -10), tStat: model.tStats.coefAge },
    { label: 'Assessment Align', value: calcImpact(model.coefAssessment), tStat: model.tStats.coefAssessment },
    { label: 'Lower Tax (-$1/sqft)', value: calcLinearImpact(model.coefTax, -1), tStat: model.tStats.coefTax },
    // Fee per sqft is tiny, so let's normalize to a typical fee shift (e.g. +$0.10/sqft ~ +$150/mo on 1500sqft)
    { label: 'Lower Fee', value: calcLinearImpact(model.coefFee, -0.10), tStat: model.tStats.coefFee },
];

// Filter features: show if valuable (impact > threshold) OR reliable (t-stat > threshold)
const featurePoints = allFeatures
    .filter(f => Math.abs(f.value) > VALUE_THRESHOLD || Math.abs(f.tStat) > TSTAT_THRESHOLD)
    .sort((a, b) => Math.abs(b.value) - Math.abs(a.value)); 
---

<section id="charts" class="py-12 bg-white border-b border-gray-200">
    <div class="max-w-6xl mx-auto px-4 md:px-6">
        <div class="flex flex-col md:flex-row justify-between items-end mb-8">
            <div>
                <h2 class="text-2xl font-bold text-gray-900 font-serif">Market Analysis</h2>
                <p class="text-sm text-gray-500 mt-1">
                    Model Confidence (RÂ²): <strong class="text-amber-600">{(model.modelConfidence * 100).toFixed(1)}%</strong>.
                    <span class="text-xs ml-2 px-2 py-0.5 bg-blue-50 text-blue-700 rounded-full">Log-Linear Regression</span>
                </p>
            </div>
        </div>
        
        <!-- Primary Charts: Feature Value Analysis -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-10">
            <!-- Neighborhoods -->
            <div class="bg-gray-50/50 p-6 rounded-xl border border-gray-100">
                <h3 class="text-sm font-bold text-gray-800 uppercase tracking-wide mb-2">Neighborhood Premiums ($)</h3>
                <p class="text-xs text-gray-400 mb-4">Estimated price impact on an average home (~${(avgPrice/1000).toFixed(0)}k) relative to {model.areaReference}.</p>
                
                <!-- City Filter -->
                <div class="flex flex-wrap gap-2 mb-4" id="areaFilterContainer">
                    {cities.map(city => (
                        <label class="inline-flex items-center px-2 py-1 rounded bg-white border border-gray-200 text-xs cursor-pointer hover:border-amber-300 transition-colors select-none shadow-sm">
                            <input 
                                type="checkbox" 
                                class="form-checkbox h-3 w-3 text-amber-600 rounded mr-2 area-filter-checkbox focus:ring-amber-500" 
                                value={city}
                                checked={defaultCities.includes(city)}
                            />
                            <span class="text-gray-700 font-medium">{city}</span>
                        </label>
                    ))}
                </div>

                <!-- Scrollable Container -->
                <div class="relative w-full h-[500px] overflow-y-auto pr-2 border-t border-gray-200 pt-2 custom-scrollbar">
                    <div class="relative w-full" id="chartAreasContainer" style={`height: ${Math.max(400, areaPoints.length * 28)}px`}>
                        <canvas id="chartAreas"></canvas>
                    </div>
                </div>
            </div>

            <!-- Features -->
            <div class="bg-gray-50/50 p-6 rounded-xl border border-gray-100">
                <h3 class="text-sm font-bold text-gray-800 uppercase tracking-wide mb-2">Feature Values ($)</h3>
                <p class="text-xs text-gray-400 mb-6">Estimated value impact on an average home. Shows features with significant impact (>|${VALUE_THRESHOLD}|) or reliability (|t-stat|>{TSTAT_THRESHOLD}). Grey = low significance.</p>
                <div class="relative h-[500px] w-full">
                    <canvas id="chartFeatures"></canvas>
                </div>
            </div>
        </div>

        <!-- Secondary Diagnostics: 3 Columns -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
            <!-- Price vs Size -->
            <div class="bg-white p-4 rounded-xl border border-gray-100 shadow-sm">
                <h3 class="text-xs font-bold text-gray-400 uppercase tracking-wide mb-4 text-center">Value by Size (Sqft)</h3>
                <div class="relative h-48 w-full">
                    <canvas id="chartPriceSize"></canvas>
                </div>
            </div>

            <!-- Price vs Age -->
            <div class="bg-white p-4 rounded-xl border border-gray-100 shadow-sm">
                <h3 class="text-xs font-bold text-gray-400 uppercase tracking-wide mb-4 text-center">Value by Age (Year Built)</h3>
                <div class="relative h-48 w-full">
                    <canvas id="chartPriceAge"></canvas>
                </div>
            </div>

            <!-- Predicted vs Actual -->
             <div class="bg-white p-4 rounded-xl border border-gray-100 shadow-sm">
                <h3 class="text-xs font-bold text-gray-400 uppercase tracking-wide mb-4 text-center">Accuracy: Pred vs Actual</h3>
                <div class="relative h-48 w-full">
                    <canvas id="chartAccuracy"></canvas>
                </div>
            </div>
        </div>
    </div>
</section>

<script define:vars={{ marketPoints, accuracyPoints, areaPoints, featurePoints, defaultCities }}>
document.addEventListener('DOMContentLoaded', () => {
    // Shared Config
    const commonOptions = {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
            legend: { display: false },
            tooltip: {
                backgroundColor: 'rgba(17, 24, 39, 0.95)',
                titleFont: { family: 'Inter', size: 13, weight: '600' },
                bodyFont: { family: 'Inter', size: 12 },
                padding: 12,
                cornerRadius: 8,
                displayColors: false,
                callbacks: {
                    label: (ctx) => {
                        const p = ctx.raw;
                        // Bar Chart
                        if (typeof p === 'number') { 
                             return `Value: ${new Intl.NumberFormat('en-CA', { style: 'currency', currency: 'CAD', maximumFractionDigits: 0 }).format(p)}`;
                        }
                        // Scatter Label
                        if (p.predicted !== undefined) {
                            return [
                                `${p.address}`,
                                `Actual: $${p.actual.toLocaleString()}`,
                                `Pred:   $${p.predicted.toLocaleString()}`
                            ];
                        }
                        // Regular scatter points
                        return p.address ? `${p.address}: $${p.y.toLocaleString()}` : `Current Property: $${p.y.toLocaleString()}`;
                    }
                }
            },
            title: { display: false }
        },
        onClick: (event, elements, chart) => {
            if (elements.length > 0) {
                const dataIndex = elements[0].index;
                const dataset = chart.data.datasets[elements[0].datasetIndex];
                const point = dataset.data[dataIndex];
                if (point && point.url) {
                    window.open(point.url, '_blank');
                }
            }
        },
        scales: {
            y: {
                ticks: {
                    callback: (val) => '$' + val / 1000 + 'k',
                    font: { size: 10, family: 'Inter' },
                    color: '#9ca3af'
                },
                grid: { color: '#f3f4f6', drawBorder: false }
            },
            x: {
                ticks: {
                    font: { size: 10, family: 'Inter' },
                    color: '#9ca3af'
                },
                grid: { color: '#f3f4f6', drawBorder: false }
            }
        },
        elements: {
            point: {
                radius: 3,
                hoverRadius: 6,
                backgroundColor: '#cbd5e1'
            }
        }
    };

    // Shared Bar Options (Horizontal)
    const barOptions = {
        ...commonOptions,
        indexAxis: 'y', // Horizontal
        interaction: {
            mode: 'y',
            axis: 'y',
            intersect: false
        },
        categoryPercentage: 0.8,
        barPercentage: 0.9,
        scales: {
            x: {
                grid: { color: '#e5e7eb', borderDash: [4, 4] },
                ticks: { 
                    font: { size: 11, family: 'Inter' },
                    color: '#6b7280',
                    callback: (val) => '$' + val/1000 + 'k' 
                }
            },
            y: {
                grid: { display: false },
                ticks: { 
                    font: { size: 12, family: 'Inter', weight: '500' },
                    color: '#111827',
                    autoSkip: false
                }
            }
        }
    };

    // Helper: Determine Color based on value and t-stat
    function getCoefficientColor(val, tStat) {
        const isSignificant = Math.abs(tStat) >= 1.65;
        if (!isSignificant) return '#9ca3af'; // Gray 400
        return val >= 0 ? '#10b981' : '#ef4444'; // Emerald 500 / Red 500
    }

    // --- Chart 1: Areas (Dynamic Filter) ---
    const ctxAreas = document.getElementById('chartAreas').getContext('2d');
    
    // Initial Filter Logic
    const getFilteredPoints = () => {
        const checkedCities = Array.from(document.querySelectorAll('.area-filter-checkbox:checked')).map(cb => cb.value);
        return areaPoints.filter(p => {
            const label = p.label; 
            const city = label.split(' - ')[0]; 
            return checkedCities.includes(city);
        });
    };

    const initialAreaPoints = getFilteredPoints();

    const chartAreas = new Chart(ctxAreas, {
        type: 'bar',
        data: {
            labels: initialAreaPoints.map(f => f.label),
            datasets: [{
                data: initialAreaPoints.map(f => f.value),
                backgroundColor: initialAreaPoints.map(f => getCoefficientColor(f.value, f.tStat)),
                borderRadius: 4
            }]
        },
        options: barOptions
    });

    // Update Area Chart Function
    function updateAreaChart() {
        const filteredPoints = getFilteredPoints();

        chartAreas.data.labels = filteredPoints.map(p => p.label);
        chartAreas.data.datasets[0].data = filteredPoints.map(p => p.value);
        chartAreas.data.datasets[0].backgroundColor = filteredPoints.map(p => getCoefficientColor(p.value, p.tStat));
        
        // Resize container dynamically
        const container = document.getElementById('chartAreasContainer');
        container.style.height = `${Math.max(400, filteredPoints.length * 28)}px`;
        
        chartAreas.update();
    }

    // Filter Listeners
    document.querySelectorAll('.area-filter-checkbox').forEach(cb => {
        cb.addEventListener('change', updateAreaChart);
    });
    
    // Initial resize call
    updateAreaChart();


    // --- Chart 2: Features ---
    const ctxFeatures = document.getElementById('chartFeatures').getContext('2d');
    new Chart(ctxFeatures, {
        type: 'bar',
        data: {
            labels: featurePoints.map(f => f.label),
            datasets: [{
                data: featurePoints.map(f => f.value),
                backgroundColor: featurePoints.map(f => getCoefficientColor(f.value, f.tStat)),
                borderRadius: 4,
                barThickness: 20
            }]
        },
        options: barOptions
    });

    // --- Chart 4: Price vs Size ---
    const ctxSize = document.getElementById('chartPriceSize').getContext('2d');
    const chartSize = new Chart(ctxSize, {
        type: 'scatter',
        data: {
            datasets: [
                {
                    label: 'Market',
                    data: marketPoints.map(p => ({ x: p.x, y: p.y, address: p.address, year: p.year, url: p.url })),
                    backgroundColor: '#cbd5e1',
                    borderWidth: 0
                },
                {
                    label: 'Subject',
                    data: [],
                    backgroundColor: '#d97706',
                    borderColor: '#ffffff',
                    borderWidth: 2,
                    pointRadius: 6,
                    order: 0
                }
            ]
        },
        options: {
            ...commonOptions,
            scales: {
                ...commonOptions.scales,
                x: { ...commonOptions.scales.x, ticks: { ...commonOptions.scales.x.ticks, maxTicksLimit: 6 } }
            }
        }
    });

    // --- Chart 5: Price vs Age ---
    const ctxAge = document.getElementById('chartPriceAge').getContext('2d');
    const chartAge = new Chart(ctxAge, {
        type: 'scatter',
        data: {
            datasets: [
                {
                    label: 'Market',
                    data: marketPoints.map(p => ({ x: p.year, y: p.y, address: p.address, url: p.url })),
                    backgroundColor: '#94a3b8',
                    borderWidth: 0
                },
                {
                    label: 'Subject',
                    data: [],
                    backgroundColor: '#d97706',
                    borderColor: '#ffffff',
                    borderWidth: 2,
                    pointRadius: 6,
                    order: 0
                }
            ]
        },
        options: {
            ...commonOptions,
            scales: {
                ...commonOptions.scales,
                x: { 
                    ...commonOptions.scales.x, 
                    ticks: { 
                        callback: (val) => val.toString().replace(',',''),
                        maxTicksLimit: 6
                    }
                }
            }
        }
    });

    // --- Chart 6: Accuracy ---
    const maxVal = Math.max(...accuracyPoints.map(p => p.actual)) * 1.1;
    const ctxAcc = document.getElementById('chartAccuracy').getContext('2d');
    const chartAcc = new Chart(ctxAcc, {
        type: 'scatter',
        data: {
            datasets: [
                {
                    label: 'Listings',
                    data: accuracyPoints.map(p => ({ x: p.actual, y: p.predicted, address: p.address, actual: p.actual, predicted: p.predicted, url: p.url })),
                    backgroundColor: (ctx) => {
                        const p = ctx.raw;
                        if (!p) return '#10b981';
                        const err = Math.abs(p.actual - p.predicted) / p.actual;
                        return err < 0.05 ? '#10b981' : (err < 0.15 ? '#f59e0b' : '#ef4444');
                    },
                    pointRadius: 2.5
                },
                {
                    type: 'line',
                    label: 'Perfect Fit',
                    data: [{x: 0, y: 0}, {x: maxVal, y: maxVal}],
                    borderColor: '#e5e7eb',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    pointRadius: 0,
                    showLine: true
                }
            ]
        },
        options: {
            ...commonOptions,
            scales: {
                ...commonOptions.scales,
                x: { 
                    ...commonOptions.scales.x, 
                    ticks: { callback: (val) => '$' + val/1000 + 'k', maxTicksLimit: 5 }
                }
            }
        }
    });

    // --- Update Logic ---
    document.addEventListener('deprecity:model-update', (e) => {
        const { price, sqft, year } = e.detail;
        chartSize.data.datasets[1].data = [{ x: sqft, y: price, year: year }];
        chartSize.update('none');
        chartAge.data.datasets[1].data = [{ x: year, y: price, year: year }];
        chartAge.update('none');
    });
    
    document.dispatchEvent(new Event('charts-ready'));
});
</script>
