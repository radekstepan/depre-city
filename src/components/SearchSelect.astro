---
interface Props {
  id: string;
  label: string;
  options: { label: string; value: string | number; meta?: number }[];
  placeholder?: string;
  initialValue?: string;
}

const { id, label, options, placeholder = "Select...", initialValue } = Astro.props;
---

<div class="relative search-select-container" data-id={id}>
  <label class="block text-xs font-bold text-gray-500 uppercase tracking-wide mb-2">
    {label}
  </label>
  
  <div class="relative">
    <input 
      type="text" 
      class="w-full p-2 border border-gray-300 rounded focus:ring-2 focus:ring-amber-500 outline-none bg-white cursor-pointer search-input"
      placeholder={placeholder}
      readonly
    />
    <!-- Hidden input to store the actual value used by logic -->
    <input type="hidden" id={id} class="value-input" value={initialValue || ""} />
    
    <div class="absolute right-3 top-2.5 pointer-events-none text-gray-400">
      <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
      </svg>
    </div>

    <!-- Dropdown -->
    <div class="hidden absolute z-50 mt-1 w-full bg-white border border-gray-200 rounded shadow-lg max-h-60 overflow-y-auto dropdown-menu">
      <div class="sticky top-0 bg-white p-2 border-b border-gray-100">
        <input 
          type="text" 
          class="w-full p-1.5 text-sm bg-gray-50 border border-gray-200 rounded outline-none focus:border-amber-500 filter-input" 
          placeholder="Type to filter..." 
        />
      </div>
      <ul class="py-1 options-list">
        {options.map(opt => (
          <li 
            class="px-4 py-2 text-sm text-gray-700 hover:bg-amber-50 cursor-pointer option-item flex justify-between" 
            data-value={opt.value}
            data-label={opt.label}
            data-meta={opt.meta}
          >
            <span>{opt.label}</span>
            {opt.meta !== undefined && (
              <span class={`text-xs font-mono ${opt.meta > 0 ? 'text-green-600' : (opt.meta < 0 ? 'text-red-500' : 'text-gray-400')}`}>
                {opt.meta > 0 ? '+' : ''}{opt.meta.toLocaleString()}
              </span>
            )}
          </li>
        ))}
      </ul>
    </div>
  </div>
</div>

<script>
  // Initialize all search selects
  document.querySelectorAll('.search-select-container').forEach(container => {
    const searchInput = container.querySelector('.search-input') as HTMLInputElement;
    const valueInput = container.querySelector('.value-input') as HTMLInputElement;
    const dropdown = container.querySelector('.dropdown-menu') as HTMLElement;
    const filterInput = container.querySelector('.filter-input') as HTMLInputElement;
    const optionsList = container.querySelector('.options-list') as HTMLElement;
    const options = Array.from(optionsList.querySelectorAll('.option-item')) as HTMLElement[];

    let isOpen = false;

    // Set initial label if value exists
    if (valueInput.value) {
      const match = options.find(opt => opt.dataset.value === valueInput.value);
      if (match) searchInput.value = match.dataset.label || "";
    }

    function toggle(state: boolean) {
      isOpen = state;
      if (isOpen) {
        dropdown.classList.remove('hidden');
        filterInput.focus();
      } else {
        dropdown.classList.add('hidden');
      }
    }

    // Toggle dropdown
    searchInput.addEventListener('click', (e) => {
      e.stopPropagation();
      toggle(!isOpen);
    });

    // Close on outside click
    document.addEventListener('click', (e) => {
      if (!container.contains(e.target as Node)) {
        toggle(false);
      }
    });

    // Filtering
    filterInput.addEventListener('input', (e) => {
      const query = (e.target as HTMLInputElement).value.toLowerCase();
      options.forEach(opt => {
        const text = (opt.dataset.label || "").toLowerCase();
        opt.style.display = text.includes(query) ? 'flex' : 'none';
      });
    });

    // Selection
    options.forEach(opt => {
      opt.addEventListener('click', () => {
        const val = opt.dataset.value || "";
        const label = opt.dataset.label || "";
        
        valueInput.value = val;
        searchInput.value = label;
        
        // Dispatch change event manually so Calculator can catch it
        valueInput.dispatchEvent(new Event('change', { bubbles: true }));
        
        toggle(false);
        filterInput.value = "";
        options.forEach(o => o.style.display = 'flex'); // Reset filter
      });
    });
  });
</script>
